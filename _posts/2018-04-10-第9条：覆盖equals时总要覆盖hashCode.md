---
layout: post
title:  "第9条：覆盖 equals 时总要覆盖 hashCode"
date:   2018-04-10 11:44:11 +0800
categories: effective-java
tag: Java
---


一个很常见的错误根源在于没有覆盖 hashCode 方法。在每个覆盖了 equals 方法的类中，也必须覆盖 hashCode 方法。如果不这样做的话，就会违反 Object.hashcode 的通用约定，从而导致该类无法结合所有基于散列的集合一起正常工作，这样的集合包括 HashMap 、 HashSet 和 Hashtable 。

###### 下面是约定的内容，摘自 Object 规范[JavaSE6]：
> - 在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对同一个对象调用多次， hashCode 方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。
> - 如果两个对象根据 equals(Object) 方法比较是相等的，那么调用这两个对象中任意一个对象的 hashCode 方法都必须产生同样的整数结果。
> - 如果两个对象根据 equals(Object) 方法比较是不相等的，那么调用这两个对象中任意一个对象的 hashCode 方法，则不一定要产生不同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。

###### 实现hashCode的简单方法：
1. 把某个非零的常数值，比如说17，保存在一个名为 result 的 int 类型的变量中。
2. 对于对象中每个关键域 f （指 equals 方法中涉及的每个域），完成以下步骤：  
   1. 为该域计算 int 类型的散列码 c :
       1. 如果该域是 boolean 类型，则计算 (f ? 1 : 0) .
       2. 如果该域是 byte 、 char 、 short 或者 int 类型，则计算 (int)f 。
       3. 如果该域是 long 类型，则计算 (int)(f ^ (f >>> 32)) 。
       4. 如果该域是 float 类型，则计算 Float.floatToIntBits(f) 。
       5. 如果该域是 double 类型，则计算 Double.doubleToLongBits(f) ，然后按照步骤2.i.c，为得到的 long 类型值计算散列值。
       6. 如果该域是一个对象引用，并且该域的 equals 方法通过递归地调用 equals 的方式来比较这个域，则同样为这个域递归地调用 hashCode 。如果需要更复杂的比较，则为这个域计算一个“范式（canonical representation）”，然后针对这个范式调用 hashCode 。如果这个域的值为 null ，则返回0（或者其他某个常数，但通常是0）。
       7. 如果该域是一个数组，则要把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤2.i中的做法把这些散列值组合起来。如果数组域中的每个元素都很重要，可以利用发行版本1.5中增加的其中一个 Arrays.hashCode 方法。
    2. 按照下面的公式，把步骤2.a中计算得到的散列码 c 合并到 result 中：  
       result = 31 * result + c;
3. 返回result。
4. 写完了 hashCode 方法之后，问问自己“相等的实例是否都具有相等的散列码”。要编写单元测试来验证你的推断。如果相等实例有着不相等的散列码，则要找出原因，并修正错误。

可以用equals中用到的变量做hash。

> 之所以选择31，是因为它是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于位移运算。使用素数的好处并不很明显，但是习惯上都使用素数来计算散列结果。31有个很好的特性，即用位移和减法来代替乘法，可以得到更好的性能， 31 * i == (i << 5) - i 。现代的VM可以自动完成这种优化。
