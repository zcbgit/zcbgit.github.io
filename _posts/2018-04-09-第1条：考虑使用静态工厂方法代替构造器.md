---
layout: post
title:  "第1条：考虑使用静态工厂方法代替构造器"
date:   2018-04-09 10:23:37 +0800
categories: effective-java
tag: Java
---


## 公有构造器与静态工厂方法
对于类而言，为了让客户端获取它自身的一个实例，最常用的方法就是提供一个公有的构造
器。还有一种方法，也应该在每个程序员的工具箱中占有一席之地。类可以提供一个公有的
静态工厂方法（static factory method），它只是一个返回类的实例的静态方法。下面是一个
来自**Boolean**（基本类型**boolean**的包装类）的简单示例。这个方法将**boolean**基本类型值
转换成了一个**Boolean**对象引用：

```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

## 静态工厂方法的优势
1. 具有名称。如果构造器的参数本身没有确切地描述正被返回的对象，那么具有适当名称的静态工厂会更容易使用，产生的客户端代码也更易于阅读。
2. 不必在每次调用它们的时候都创建一个新对象。这使得不可变类（见第15条）可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象。静态工厂方法能够为重复的调用返回相同的对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。
3. 它们可以返回原返回类型的任何子类型的对象。这样我们在选择返回对象的类时就有了更大的灵活性。
4. 在创建参数化类型实例的时候，它们使代码变得更加简洁。

    如以下创建对像的代码：

    ```
    Map<String, List<String>> m = new HashMap<String, List<String>>();
    ```
    假设HashMap提供了以下静态工厂方法：
    ```
    public static <K, V> HashMap<K, V> newInstance() {
        return new HashMap<K, V>();
    }
    ```
    就可以这样进行实例化
    
    ```
    Map<String, List<String>> m = HashMap.newInstance();
    ```

## 静态工厂方法的缺点
1. 类如果不含有公有的或者受保护的构造器，就不能被子类化。这一点应该这么理解：就是如果提供静态的工厂方法，则构造器一般会私有化，如果有子类需要继承该类是没法继承的。
2. 它们与其他的静态方法实际上没有任何区别。在API文档中，它们没有像构造器那样在API文档中明确标识出来。

## 静态工厂方法的一些惯用名称
- valueOf ―― 不太严格地讲，该方法返回的实例与它的参数具有相同的值。这样的静态工厂方法实际上是类型转化方法。
- of ―― valueOf的一种更为简洁的替代，在EnumSet（见第32条）中使用并流行起来。
- getInstance ―― 返回的实例是通过方法的参数来描述的，但是不能够说与参数具有同样的值。对于Singleton来说，该方法没有参数，并返回唯一的实例。
- newInstance ―― 像getInstance一样，但newInstance能够确保返回的每个实例都与所有其他实例不同。
- getType ―― 像getInstance一样，但是在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型。
- newType ―― 像newInstance一样，但是在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型。
